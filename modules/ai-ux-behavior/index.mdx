---
title: "AI UX Behavior & Design Patterns"
slug: "modules-ai-ux-behavior"
updatedAt: "2025-08-18"
tags: [module, ux, design, ai-patterns, claude, anthropic]
---

# AI UX Behavior & Design Patterns

> **Synthesis**: Understanding how users interact with AI systems and designing intuitive, trustworthy, and effective user experiences for AI-powered applications, with special focus on Claude's conversational capabilities.

## Why it's important for designers to know

AI UX behavior is fundamentally different from traditional software UX. Users interact with AI systems through conversation, expect intelligent responses, and need clear feedback about system capabilities and limitations. Designers must understand:

- **Conversational Design**: How to structure AI interactions that feel natural and productive
- **Trust & Transparency**: Building user confidence through clear communication about AI capabilities
- **Error Handling**: Graceful degradation when AI fails or provides unexpected responses
- **Progressive Disclosure**: Revealing AI capabilities gradually to avoid overwhelming users
- **Feedback Loops**: Providing clear signals about what the AI is doing and thinking

<Callout type="info">
  **Claude's UX Advantages**: Claude's constitutional AI principles and natural conversational abilities make it particularly well-suited for creating trustworthy, helpful user experiences.
</Callout>

## Claude's UX Strengths

### Natural Conversation Flow

<Card title="Claude's Conversational Design">
  <p>Claude excels at natural, helpful conversations that feel more human-like than traditional chatbots:</p>
  
  <h4>Conversational Capabilities:</h4>
  <ul>
    <li><strong>Context Awareness:</strong> Maintains conversation context across multiple turns</li>
    <li><strong>Natural Language:</strong> Understands and responds in natural, conversational language</li>
    <li><strong>Helpful Tone:</strong> Consistently helpful and supportive in interactions</li>
    <li><strong>Clarification Skills:</strong> Asks for clarification when needed</li>
    <li><strong>Proactive Assistance:</strong> Offers helpful suggestions and alternatives</li>
  </ul>
  
  <h4>UX Benefits:</h4>
  <ul>
    <li><strong>Reduced Friction:</strong> Users don't need to learn specific commands or syntax</li>
    <li><strong>Increased Trust:</strong> Natural conversation builds user confidence</li>
    <li><strong>Better Engagement:</strong> More engaging than rigid question-answer formats</li>
    <li><strong>Accessibility:</strong> Easier for users with varying technical skills</li>
  </ul>
</Card>

### Trust and Transparency

<Card title="Building Trust with Claude">
  <h4>Trust-Building Features:</h4>
  <ul>
    <li><strong>Honest Communication:</strong> Claude admits when it doesn't know something</li>
    <li><strong>Capability Clarity:</strong> Clear about what it can and cannot do</li>
    <li><strong>Safe Responses:</strong> Built-in safety prevents harmful outputs</li>
    <li><strong>Consistent Behavior:</strong> Predictable, reliable responses</li>
  </ul>
  
  <h4>Transparency Patterns:</h4>
  <ul>
    <li><strong>Confidence Indicators:</strong> Show when Claude is certain vs uncertain</li>
    <li><strong>Source Attribution:</strong> Cite sources when providing information</li>
    <li><strong>Limitation Disclosure:</strong> Clear about capabilities and constraints</li>
    <li><strong>Error Explanation:</strong> Explain why certain requests can't be fulfilled</li>
  </ul>
</Card>

## AI UX Design Patterns

<Tabs>
  <Tab title="Good Design" icon="check-circle">
    ### ‚úÖ Good AI UX Design with Claude
    
    **Progressive Disclosure**: Provides clear options without overwhelming
    - **Graceful Error Handling**: Acknowledges limitations and offers alternatives
    - **Confidence Transparency**: Shows clear confidence levels and reasoning
    - **User Control**: Gives users clear choices and control over complexity
    - **Contextual Awareness**: Maintains conversation context and relevance
    - **Claude Integration**: Leverages Claude's natural conversational abilities
    
    **Example Implementation:**
    ```python
    import anthropic
    
    class GoodClaudeUXSystem:
        def __init__(self):
            self.client = anthropic.Anthropic(api_key="your-api-key")
            self.context_manager = ContextManager()
            self.confidence_detector = ConfidenceDetector()
            self.user_preference_tracker = UserPreferenceTracker()
        
        def generate_response(self, user_input, conversation_history):
            # Progressive disclosure
            if self.is_broad_question(user_input):
                return self.generate_options_response(user_input)
            
            # Graceful error handling
            if not self.can_handle_request(user_input):
                return self.generate_alternative_suggestions(user_input)
            
            # Use Claude's natural conversation abilities
            response = self.client.messages.create(
                model="claude-3-sonnet-20240229",
                max_tokens=1000,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a helpful assistant. Be conversational, honest about your capabilities, and offer alternatives when you can't help."
                    },
                    *conversation_history,
                    {
                        "role": "user",
                        "content": user_input
                    }
                ]
            )
            
            # Add confidence indicators
            confidence = self.confidence_detector.assess(user_input, response.content[0].text)
            
            # User control based on preferences
            if self.user_preference_tracker.prefers_simple(user_input):
                return self.generate_simple_response(response.content[0].text, confidence)
            else:
                return self.generate_detailed_response(response.content[0].text, confidence)
        
        def generate_options_response(self, question):
            return {
                "response": "I'd be happy to help! What specific area are you working on?",
                "options": ["Basic concepts", "Advanced topics", "Practical examples"],
                "confidence": "high",
                "user_control": True,
                "claude_enhanced": True
            }
    ```
  </Tab>
  
  <Tab title="Poor Design" icon="x-circle">
    ### ‚ùå Poor AI UX Design
    
    **Information Overload**: Dumps too much information without guidance
    - **Abrupt Failures**: Provides no recovery path when errors occur
    - **Uncertain Responses**: Shows lack of confidence without explanation
    - **No User Control**: Assumes user wants maximum complexity
    - **Context Loss**: Fails to maintain conversation flow
    - **Ignoring Claude Strengths**: Doesn't leverage Claude's conversational abilities
    
    **Example Implementation:**
    ```python
    class PoorAIUXSystem:
        def __init__(self):
            # No context management
            # No confidence detection
            # No user preference tracking
            # No Claude integration
        
        def generate_response(self, user_input):
            # Information dump without structure
            if self.is_broad_question(user_input):
                return self.dump_all_information(user_input)
            
            # Abrupt failure
            if not self.can_handle_request(user_input):
                return "I cannot help with that."
            
            # No confidence assessment
            # No user control
            # No context consideration
            # No Claude integration
            return self.generate_verbose_response(user_input)
        
        def dump_all_information(self, question):
            return {
                "response": "Here's everything about this topic... [500+ words]",
                "confidence": "unknown",
                "user_control": False,
                "context_aware": False,
                "claude_enhanced": False
            }
    ```
  </Tab>
</Tabs>

## Claude-Specific UX Patterns

### 1. **Conversational Onboarding**

<Card title="Onboarding with Claude">
  <h4>Design Principles:</h4>
  <ul>
    <li><strong>Welcome Message:</strong> Friendly, helpful introduction</li>
    <li><strong>Capability Overview:</strong> Clear explanation of what Claude can do</li>
    <li><strong>Example Interactions:</strong> Show users how to interact effectively</li>
    <li><strong>Progressive Discovery:</strong> Reveal advanced features gradually</li>
  </ul>
  
  <h4>Implementation Example:</h4>
  <pre><code>def create_claude_onboarding():
    welcome_message = """
    Hi! I'm Claude, your AI assistant. I can help you with:
    
    ‚Ä¢ Answering questions and explaining concepts
    ‚Ä¢ Analyzing documents and data
    ‚Ä¢ Writing and editing content
    ‚Ä¢ Solving problems and brainstorming ideas
    
    Just ask me anything! I'm here to help.
    
    üí° Tip: Be specific with your questions for better answers.
    """
    
    return {
        "message": welcome_message,
        "suggestions": [
            "What can you help me with?",
            "Show me an example of your capabilities",
            "How do I get the best results?"
        ],
        "next_steps": "Try asking me a question or uploading a document!"
    }
</code></pre>
</Card>

### 2. **Confidence and Uncertainty**

<Card title="Confidence Indicators with Claude">
  <h4>Confidence Levels:</h4>
  <ul>
    <li><strong>High Confidence:</strong> Clear, direct answers with sources</li>
    <li><strong>Medium Confidence:</strong> Qualified responses with caveats</li>
    <li><strong>Low Confidence:</strong> Honest uncertainty with alternatives</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>def generate_confidence_indicator(response_text, confidence_score):
    if confidence_score >= 0.8:
        return {
            "response": response_text,
            "confidence": "high",
            "indicator": "‚úÖ",
            "message": "I'm confident about this information."
        }
    elif confidence_score >= 0.5:
        return {
            "response": response_text,
            "confidence": "medium",
            "indicator": "ü§î",
            "message": "This is my best understanding, but you may want to verify."
        }
    else:
        return {
            "response": response_text,
            "confidence": "low",
            "indicator": "‚ùì",
            "message": "I'm not entirely sure about this. Here are some alternatives..."
        }
</code></pre>
</Card>

### 3. **Error Handling and Recovery**

<Card title="Graceful Error Handling">
  <h4>Error Types and Responses:</h4>
  <ul>
    <li><strong>Unclear Requests:</strong> Ask for clarification</li>
    <li><strong>Out of Scope:</strong> Explain limitations and suggest alternatives</li>
    <li><strong>Technical Issues:</strong> Provide helpful error messages</li>
    <li><strong>Safety Concerns:</strong> Explain why certain requests can't be fulfilled</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>def handle_claude_errors(error_type, user_input):
    error_handlers = {
        "unclear": {
            "message": "I'm not sure I understand. Could you rephrase that?",
            "suggestions": ["Can you be more specific?", "What exactly are you looking for?"],
            "help_text": "Try being more specific about what you need help with."
        },
        "out_of_scope": {
            "message": "I can't help with that specific request, but I can help with related topics.",
            "suggestions": ["What's your main goal?", "Is there something else I can help with?"],
            "help_text": "I'm designed to help with information, analysis, and creative tasks."
        },
        "technical": {
            "message": "I'm having trouble processing that. Let's try a different approach.",
            "suggestions": ["Try rephrasing your question", "Break it down into smaller parts"],
            "help_text": "Sometimes simpler, more direct questions work better."
        },
        "safety": {
            "message": "I can't help with that request, but I'm happy to help with other things.",
            "suggestions": ["What's your main goal?", "How else can I assist you?"],
            "help_text": "I'm designed to be helpful while maintaining safety and ethical standards."
        }
    }
    
    handler = error_handlers.get(error_type, error_handlers["unclear"])
    
    return {
        "response": handler["message"],
        "suggestions": handler["suggestions"],
        "help_text": handler["help_text"],
        "error_type": error_type
    }
</code></pre>
</Card>

### 4. **Progressive Disclosure**

<Card title="Progressive Information Disclosure">
  <h4>Disclosure Strategy:</h4>
  <ul>
    <li><strong>Start Simple:</strong> Provide basic information first</li>
    <li><strong>Offer Details:</strong> Give users the option to learn more</li>
    <li><strong>Contextual Help:</strong> Provide help when users need it</li>
    <li><strong>User Control:</strong> Let users choose their level of detail</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>def progressive_disclosure_response(user_input, detail_level="basic"):
    if detail_level == "basic":
        return {
            "response": "Here's a simple answer to your question...",
            "show_more": True,
            "more_options": ["Detailed explanation", "Examples", "Related topics"]
        }
    elif detail_level == "detailed":
        return {
            "response": "Here's a comprehensive answer with examples and context...",
            "show_more": False,
            "related_topics": ["Topic 1", "Topic 2", "Topic 3"]
        }
    
    return {
        "response": "I'd be happy to help! What level of detail would you prefer?",
        "options": ["Quick answer", "Detailed explanation", "Step-by-step guide"]
    }
</code></pre>
</Card>

## Advanced UX Patterns

### 1. **Multi-Modal Interactions**

<Card title="Claude's Multi-Modal UX">
  <h4>Interaction Types:</h4>
  <ul>
    <li><strong>Text + Vision:</strong> Analyze images while discussing text</li>
    <li><strong>Document Analysis:</strong> Process and explain documents</li>
    <li><strong>Data Visualization:</strong> Interpret charts and graphs</li>
    <li><strong>Code Review:</strong> Analyze code screenshots</li>
  </ul>
  
  <h4>UX Considerations:</h4>
  <ul>
    <li><strong>Clear Upload Interface:</strong> Easy file upload and drag-and-drop</li>
    <li><strong>Processing Feedback:</strong> Show when Claude is analyzing content</li>
    <li><strong>Context Preservation:</strong> Maintain conversation context with visual content</li>
    <li><strong>Accessibility:</strong> Provide text alternatives for visual content</li>
  </ul>
</Card>

### 2. **Tool Integration UX**

<Card title="Tool Use User Experience">
  <h4>Tool Interaction Patterns:</h4>
  <ul>
    <li><strong>Automatic Tool Selection:</strong> Claude chooses appropriate tools</li>
    <li><strong>Tool Execution Feedback:</strong> Show when tools are being used</li>
    <li><strong>Result Integration:</strong> Seamlessly incorporate tool results</li>
    <li><strong>Error Handling:</strong> Graceful handling of tool failures</li>
  </ul>
  
  <h4>Implementation Example:</h4>
  <pre><code>def tool_integration_ux(tool_name, tool_result, user_query):
    tool_messages = {
        "web_search": "I searched the web for current information about this...",
        "calculator": "I calculated the result for you...",
        "file_reader": "I analyzed the document you provided...",
        "code_executor": "I ran the code and here are the results..."
    }
    
    return {
        "tool_used": tool_name,
        "tool_message": tool_messages.get(tool_name, "I used a tool to help with your request..."),
        "result": tool_result,
        "context": "Based on the " + tool_name + " results, here's what I found...",
        "user_query": user_query
    }
</code></pre>
</Card>

### 3. **Personalization and Adaptation**

<Card title="Personalized UX with Claude">
  <h4>Personalization Features:</h4>
  <ul>
    <li><strong>User Preferences:</strong> Remember user's preferred detail level</li>
    <li><strong>Interaction History:</strong> Adapt based on previous conversations</li>
    <li><strong>Domain Expertise:</strong> Adjust responses based on user's knowledge level</li>
    <li><strong>Communication Style:</strong> Match user's preferred tone and style</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>class PersonalizedClaudeUX:
    def __init__(self):
        self.user_profiles = \{\}
        self.interaction_history = \{\}
    
    def adapt_response(self, user_id, response, user_input):
        profile = self.user_profiles.get(user_id, \{\})
        
        # Adapt detail level
        if profile.get("prefers_simple"):
            response = self.simplify_response(response)
        
        # Adapt tone
        if profile.get("prefers_formal"):
            response = self.make_formal(response)
        elif profile.get("prefers_casual"):
            response = self.make_casual(response)
        
        # Adapt based on expertise level
        expertise_level = profile.get("expertise_level", "intermediate")
        response = self.adjust_for_expertise(response, expertise_level)
        
        return response
    
    def update_user_profile(self, user_id, interaction_data):
        # Update user preferences based on interactions
        if user_id not in self.user_profiles:
            self.user_profiles[user_id] = \{\}
        
        # Analyze interaction patterns
        detail_preference = self.analyze_detail_preference(interaction_data)
        tone_preference = self.analyze_tone_preference(interaction_data)
        expertise_level = self.analyze_expertise_level(interaction_data)
        
        self.user_profiles[user_id].update(\{
            "prefers_simple": detail_preference == "simple",
            "prefers_formal": tone_preference == "formal",
            "expertise_level": expertise_level
        \})
</code></pre>
</Card>

## Performance and Responsiveness

### 1. **Streaming Responses**

<Card title="Real-Time Feedback with Claude">
  <h4>Streaming Benefits:</h4>
  <ul>
    <li><strong>Perceived Performance:</strong> Users see immediate feedback</li>
    <li><strong>Engagement:</strong> Keeps users engaged during processing</li>
    <li><strong>Interruption Support:</strong> Users can interrupt if needed</li>
    <li><strong>Progress Indication:</strong> Shows that work is being done</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>async def stream_claude_response(user_input):
    async with anthropic.Anthropic(api_key="your-api-key") as client:
        stream = await client.messages.create(
            model="claude-3-sonnet-20240229",
            max_tokens=1000,
            messages=[\{"role": "user", "content": user_input\}],
            stream=True
        )
        
        async for chunk in stream:
            if chunk.type == "content_block_delta":
                yield \{
                    "type": "content",
                    "text": chunk.delta.text,
                    "partial": True
                \}
            elif chunk.type == "message_stop":
                yield \{
                    "type": "complete",
                    "text": "",
                    "partial": False
                \}
</code></pre>
</Card>

### 2. **Loading States and Feedback**

<Card title="Loading State Design">
  <h4>Loading Patterns:</h4>
  <ul>
    <li><strong>Typing Indicators:</strong> Show Claude is "thinking"</li>
    <li><strong>Progress Bars:</strong> For longer operations</li>
    <li><strong>Status Messages:</strong> Explain what's happening</li>
    <li><strong>Cancel Options:</strong> Allow users to stop processing</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>def create_loading_states():
    return {
        "thinking": {
            "message": "Claude is thinking...",
            "icon": "ü§î",
            "animation": "pulse"
        },
        "analyzing": {
            "message": "Analyzing your request...",
            "icon": "üîç",
            "animation": "spin"
        },
        "searching": {
            "message": "Searching for information...",
            "icon": "üîé",
            "animation": "bounce"
        },
        "processing": {
            "message": "Processing your input...",
            "icon": "‚öôÔ∏è",
            "animation": "rotate"
        }
    }
</code></pre>
</Card>

## Accessibility and Inclusion

### 1. **Universal Design Principles**

<Card title="Accessible AI UX">
  <h4>Accessibility Features:</h4>
  <ul>
    <li><strong>Screen Reader Support:</strong> Proper ARIA labels and descriptions</li>
    <li><strong>Keyboard Navigation:</strong> Full keyboard accessibility</li>
    <li><strong>High Contrast:</strong> Support for high contrast modes</li>
    <li><strong>Font Scaling:</strong> Responsive text sizing</li>
    <li><strong>Alternative Input:</strong> Voice input and other modalities</li>
  </ul>
  
  <h4>Implementation Guidelines:</h4>
  <pre><code>def create_accessible_interface():
    return {
        "aria_labels": {
            "chat_input": "Type your message to Claude",
            "send_button": "Send message to Claude",
            "upload_button": "Upload file for Claude to analyze",
            "settings_button": "Open Claude settings"
        },
        "keyboard_shortcuts": {
            "send_message": "Enter",
            "new_conversation": "Ctrl+N",
            "upload_file": "Ctrl+U",
            "settings": "Ctrl+,"
        },
        "focus_management": {
            "auto_focus": "chat_input",
            "focus_after_send": "chat_input",
            "focus_after_upload": "chat_input"
        }
    }
</code></pre>
</Card>

### 2. **Inclusive Language and Content**

<Card title="Inclusive AI Interactions">
  <h4>Inclusive Design Principles:</h4>
  <ul>
    <li><strong>Diverse Examples:</strong> Use examples from various cultures and backgrounds</li>
    <li><strong>Gender-Neutral Language:</strong> Avoid assumptions about gender</li>
    <li><strong>Cultural Sensitivity:</strong> Respect different cultural perspectives</li>
    <li><strong>Age-Appropriate Content:</strong> Adapt content for different age groups</li>
  </ul>
  
  <h4>Implementation:</h4>
  <pre><code>def create_inclusive_prompts():
    return {
        "system_prompt": """
        You are a helpful, inclusive AI assistant. When providing examples or references:
        - Use diverse examples from various cultures and backgrounds
        - Use gender-neutral language when possible
        - Be culturally sensitive and respectful
        - Consider different perspectives and experiences
        - Avoid stereotypes and assumptions
        """,
        "example_prompts": [
            "Can you provide examples from different cultural perspectives?",
            "How might this apply to people from various backgrounds?",
            "What are some alternative approaches to consider?"
        ]
    }
</code></pre>
</Card>

## Testing and Evaluation

### 1. **UX Testing Methods**

<Card title="AI UX Testing">
  <h4>Testing Approaches:</h4>
  <ul>
    <li><strong>Usability Testing:</strong> Observe real users interacting with Claude</li>
    <li><strong>A/B Testing:</strong> Compare different UX approaches</li>
    <li><strong>Conversation Analysis:</strong> Analyze conversation patterns and flows</li>
    <li><strong>Accessibility Testing:</strong> Test with users who have disabilities</li>
  </ul>
  
  <h4>Testing Metrics:</h4>
  <ul>
    <li><strong>Task Completion Rate:</strong> How often users achieve their goals</li>
    <li><strong>Time to Completion:</strong> How long tasks take</li>
    <li><strong>User Satisfaction:</strong> Subjective ratings and feedback</li>
    <li><strong>Error Rate:</strong> How often users encounter problems</li>
  </ul>
</Card>

### 2. **Continuous Improvement**

<Card title="Iterative UX Improvement">
  <h4>Improvement Process:</h4>
  <ul>
    <li><strong>Data Collection:</strong> Gather usage data and user feedback</li>
    <li><strong>Pattern Analysis:</strong> Identify common issues and opportunities</li>
    <li><strong>Hypothesis Formation:</strong> Develop theories about improvements</li>
    <li><strong>Testing and Validation:</strong> Test improvements with users</li>
    <li><strong>Implementation:</strong> Deploy successful improvements</li>
  </ul>
  
  <h4>Feedback Loops:</h4>
  <pre><code>def create_feedback_system():
    return {
        "user_feedback": {
            "thumbs_up": "Track positive interactions",
            "thumbs_down": "Track negative interactions",
            "text_feedback": "Collect detailed user comments",
            "suggestion_box": "Allow feature requests"
        },
        "analytics": {
            "conversation_length": "Track conversation duration",
            "completion_rate": "Track task completion",
            "error_frequency": "Track common errors",
            "user_satisfaction": "Track satisfaction scores"
        },
        "improvement_cycle": {
            "collect": "Gather data and feedback",
            "analyze": "Identify patterns and issues",
            "design": "Create improvement hypotheses",
            "test": "Validate improvements",
            "implement": "Deploy successful changes"
        }
    }
</code></pre>
</Card>

## Key Design Principles

### 1. **Progressive Disclosure**
- Start simple, add complexity on demand
- Provide clear navigation paths
- Don't overwhelm with options upfront

### 2. **Transparency & Trust**
- Be clear about AI capabilities and limitations
- Show confidence levels when appropriate
- Explain reasoning when possible
- Leverage Claude's built-in honesty

### 3. **Graceful Degradation**
- Always provide a path forward
- Offer alternatives when primary approach fails
- Maintain usefulness even in error states

### 4. **User Control & Freedom**
- Give users clear choices and control
- Allow interruption and redirection
- Provide escape hatches from complex paths

### 5. **Consistent Feedback**
- Show what the AI is doing
- Provide clear success/error states
- Maintain conversation context

### 6. **Natural Conversation**
- Leverage Claude's conversational abilities
- Maintain context across interactions
- Use natural language patterns
- Provide helpful, supportive responses

## Collaboration prompts for engineers

### For Frontend Developers
```
"Can we add a confidence indicator that shows when Claude is certain vs uncertain about its responses? This helps users understand when to trust the AI's advice."
```

### For Backend Developers
```
"We need to implement streaming responses so users see Claude working in real-time. This reduces perceived latency and builds trust."
```

### For UX Researchers
```
"Let's A/B test different error message formats to see which ones help users recover and continue their workflow most effectively."
```

### For Product Managers
```
"We should track user satisfaction after Claude interactions to understand which UX patterns lead to better outcomes and user retention."
```

### For Accessibility Specialists
```
"How can we ensure our Claude interface is fully accessible to users with disabilities? What additional features do we need?"
```

## Related Concepts

<CardGroup cols={2}>
  <Card title="Prompt Engineering" icon="edit" href="../prompting-techniques/chain-of-thought">
    Design effective prompts for Claude
  </Card>
  <Card title="Evaluation & Observability" icon="monitor" href="../evaluation-observability">
    Measure UX effectiveness
  </Card>
  <Card title="Safety & Security" icon="shield" href="../safety-security">
    Build trustworthy AI experiences
  </Card>
  <Card title="Multimodality" icon="image" href="../multimodality">
    Design for multiple interaction types
  </Card>
  <Card title="Tool Use" icon="wrench" href="../prompting-techniques/react">
    Integrate external tools seamlessly
  </Card>
  <Card title="Streaming UX" icon="zap" href="../streaming-ux">
    Real-time interaction patterns
  </Card>
</CardGroup>

> **Note:** The following article is reproduced verbatim from  
> Smashing Magazine Team, *Smashing Magazine* (2025):  
> [How To Design Effective Conversational AI Experiences: A Comprehensive Guide](https://www.smashingmagazine.com/2024/07/how-design-effective-conversational-ai-experiences-guide/)  
> for internal educational use only (non-profit).

# How To Design Effective Conversational AI Experiences: A Comprehensive Guide

Conversational AI is revolutionizing information access, offering a personalized, intuitive search experience that delights users and empowers businesses. A well-designed conversational agent acts as a knowledgeable guide, understanding user intent and effortlessly navigating vast data, which leads to happier, more engaged users, fostering loyalty and trust. Meanwhile, businesses benefit from increased efficiency, reduced costs, and a stronger bottom line. On the other hand, a poorly designed system can lead to frustration, confusion, and, ultimately, abandonment.

Achieving success with conversational AI requires more than just deploying a chatbot. To truly harness this technology, we must master the intricate dynamics of human-AI interaction. This involves understanding how users articulate needs, explore results, and refine queries, paving the way for a seamless and effective search experience.

This article will decode the three phases of conversational search, the challenges users face at each stage, and the strategies and best practices AI agents can employ to enhance the experience.

## The Three Phases Of Conversational Search

To analyze these complex interactions, Trippas et al. (2018) (PDF) proposed a framework that outlines three core phases in the conversational search process:

1. **Query formulation**: Users express their information needs, often facing challenges in articulating them clearly.
2. **Search results exploration**: Users navigate through presented results, seeking further information and refining their understanding.
3. **Query re-formulation**: Users refine their search based on new insights, adapting their queries and exploring different avenues.

Building on this framework, Azzopardi et al. (2018) (PDF) identified five key user actions within these phases: reveal, inquire, navigate, interrupt, interrogate, and the corresponding agent actions ‚Äî inquire, reveal, traverse, suggest, and explain.

![Table created by the author based on Azzopardi et al.'s paper](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-design-effective-conversational-ai-experiences-guide/1-table-three-phases-conversational-search.png)
<sub>Source: *Smashing Magazine*, Smashing Magazine Team (2025).</sub>

In the following sections, I'll break down each phase of the conversational search journey, delving into the actions users take and the corresponding strategies AI agents can employ, as identified by Azzopardi et al. (2018) (PDF). I'll also share actionable tactics and real-world examples to guide the implementation of these strategies.

## Phase 1: Query Formulation: The Art Of Articulation

In the initial phase of query formulation, users attempt to translate their needs into prompts. This process involves conscious disclosures ‚Äî sharing details they believe are relevant ‚Äî and unconscious non-disclosure ‚Äî omitting information they may not deem important or struggle to articulate.

This process is fraught with challenges. As Jakob Nielsen aptly pointed out,

> "Articulating ideas in written prose is hard. Most likely, half the population can't do it. This is a usability problem for current prompt-based AI user interfaces."‚Äî Jakob Nielsen

This can manifest as:

- **Vague language**: "I need help with my finances." Budgeting? Investing? Debt management?
- **Missing details**: "I need a new pair of shoes." What type of shoes? For what purpose?
- **Limited vocabulary**: Not knowing the right technical terms. "I think I have a sprain in my ankle." The user might not know the difference between a sprain and a strain or the correct anatomical terms.

These challenges can lead to frustration for users and less relevant results from the AI agent.

### AI Agent Strategies: Nudging Users Towards Better Input

To bridge the articulation gap, AI agents can employ three core strategies:

1. **Elicit**: Proactively guide users to provide more information.
2. **Clarify**: Seek to resolve ambiguities in the user's query.

## Sources

- **NN Group Research**: [AI Chatbots Discourage Error Checking](https://www.nngroup.com/articles/ai-chatbots-discourage-error-checking/)
- **Prompt Engineering Guide**: [AI UX Patterns](https://www.promptingguide.ai/)
- **Anthropic Research**: [Building Effective AI Agents](https://www.anthropic.com/engineering/building-effective-agents)
- **CrewAI Documentation**: [Agent Design Patterns](https://docs.crewai.com/en/concepts/agents)
- **Claude Documentation**: [Best Practices for Claude](https://docs.anthropic.com/en/docs/best-practices)

## Figures

- Conversation flow diagrams showing good vs bad patterns
- Confidence indicator mockups
- Error handling state diagrams
- User control interface examples
- Progressive disclosure examples
- Accessibility interface mockups

