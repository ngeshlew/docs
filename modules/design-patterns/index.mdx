---
title: "Design Patterns"
slug: "modules-design-patterns"
updatedAt: "2025-08-18"
tags: [module, design-patterns, architecture, best-practices]
---

# Design Patterns

> Learn essential design patterns for building scalable, maintainable, and efficient AI-powered applications.

## What are Design Patterns?

Design patterns are proven solutions to common problems in software design. They provide reusable templates for solving recurring design challenges, making code more maintainable, scalable, and understandable. In AI applications, design patterns help structure complex interactions between models, data, and user interfaces.

## Why Design Patterns Matter

### Benefits

- **Reusability**: Proven solutions that can be applied across projects
- **Maintainability**: Well-structured code that's easier to understand and modify
- **Scalability**: Patterns that support growth and complexity
- **Consistency**: Standardized approaches across teams and projects
- **Best Practices**: Incorporates industry-proven methodologies

### Common Challenges in AI Applications

- Complex model interactions
- State management across sessions
- Error handling and fallbacks
- Performance optimization
- User experience consistency

## Creational Patterns

### Singleton Pattern

Ensure a class has only one instance and provide global access to it.

```python
class AIConfigManager:
    _instance = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self.config = \{\}
            self._initialized = True
    
    def set_config(self, key: str, value: any):
        self.config[key] = value
    
    def get_config(self, key: str):
        return self.config.get(key)

# Usage
config_manager = AIConfigManager()
config_manager.set_config('model_name', 'gpt-4')
```

### Factory Pattern

Create objects without specifying their exact class.

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class AIModel(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass

class GPTModel(AIModel):
    def generate(self, prompt: str) -> str:
        return f"GPT response to: \{prompt\}"

class ClaudeModel(AIModel):
    def generate(self, prompt: str) -> str:
        return f"Claude response to: \{prompt\}"

class AIModelFactory:
    @staticmethod
    def create_model(model_type: str) -> AIModel:
        models = {
            'gpt': GPTModel,
            'claude': ClaudeModel
        }
        
        if model_type not in models:
            raise ValueError(f"Unknown model type: \{model_type\}")
        
        return models[model_type]()

# Usage
factory = AIModelFactory()
gpt_model = factory.create_model('gpt')
claude_model = factory.create_model('claude')
```

## Structural Patterns

### Adapter Pattern

Allow incompatible interfaces to work together.

```python
class LegacyAIService:
    def process_text(self, text: str) -> Dict[str, str]:
        return \{"result": f"Legacy processed: \{text\}"\}

class ModernAIInterface:
    def generate_response(self, input_text: str) -> str:
        return f"Modern response: \{input_text\}"

class AIAdapter:
    def __init__(self, legacy_service: LegacyAIService):
        self.legacy_service = legacy_service
    
    def generate_response(self, input_text: str) -> str:
        # Adapt the legacy interface to the modern one
        result = self.legacy_service.process_text(input_text)
        return result["result"]

# Usage
legacy_service = LegacyAIService()
adapter = AIAdapter(legacy_service)
response = adapter.generate_response("Hello, world!")
```

### Decorator Pattern

Add new functionality to objects without altering their structure.

```python
from abc import ABC, abstractmethod

class AIResponse(ABC):
    @abstractmethod
    def get_response(self) -> str:
        pass

class BasicAIResponse(AIResponse):
    def __init__(self, text: str):
        self.text = text
    
    def get_response(self) -> str:
        return self.text

class ResponseDecorator(AIResponse):
    def __init__(self, ai_response: AIResponse):
        self.ai_response = ai_response
    
    def get_response(self) -> str:
        return self.ai_response.get_response()

class LoggingDecorator(ResponseDecorator):
    def get_response(self) -> str:
        response = self.ai_response.get_response()
        print(f"Logging response: \{response\}")
        return response

class CachingDecorator(ResponseDecorator):
    def __init__(self, ai_response: AIResponse):
        super().__init__(ai_response)
        self.cache = \{\}
    
    def get_response(self) -> str:
        # Simple caching implementation
        response = self.ai_response.get_response()
        if response not in self.cache:
            self.cache[response] = response
        return self.cache[response]

# Usage
basic_response = BasicAIResponse("Hello, AI!")
logged_response = LoggingDecorator(basic_response)
cached_logged_response = CachingDecorator(logged_response)
result = cached_logged_response.get_response()
```

## Behavioral Patterns

### Observer Pattern

Define a one-to-many dependency between objects.

```python
from abc import ABC, abstractmethod
from typing import List

class Observer(ABC):
    @abstractmethod
    def update(self, message: str):
        pass

class AIService:
    def __init__(self):
        self.observers: List[Observer] = []
    
    def add_observer(self, observer: Observer):
        self.observers.append(observer)
    
    def remove_observer(self, observer: Observer):
        self.observers.remove(observer)
    
    def notify_observers(self, message: str):
        for observer in self.observers:
            observer.update(message)
    
    def process_request(self, request: str):
        # Process the request
        result = f"Processed: \{request\}"
        # Notify all observers
        self.notify_observers(result)

class LoggingObserver(Observer):
    def update(self, message: str):
        print(f"Logging: \{message\}")

class MetricsObserver(Observer):
    def update(self, message: str):
        print(f"Metrics: Processing request of length \{len(message)\}")

# Usage
ai_service = AIService()
logging_observer = LoggingObserver()
metrics_observer = MetricsObserver()

ai_service.add_observer(logging_observer)
ai_service.add_observer(metrics_observer)

ai_service.process_request("Hello, AI!")
```

### Strategy Pattern

Define a family of algorithms and make them interchangeable.

```python
from abc import ABC, abstractmethod

class PromptStrategy(ABC):
    @abstractmethod
    def generate_prompt(self, input_text: str) -> str:
        pass

class SimplePromptStrategy(PromptStrategy):
    def generate_prompt(self, input_text: str) -> str:
        return f"Answer this question: \{input_text\}"

class DetailedPromptStrategy(PromptStrategy):
    def generate_prompt(self, input_text: str) -> str:
        return f"""
        Please provide a detailed and comprehensive answer to the following question.
        Include examples, explanations, and relevant context.
        
        Question: \{input_text\}
        
        Please structure your response with:
        1. Direct answer
        2. Explanation
        3. Examples
        4. Related concepts
        """

class CreativePromptStrategy(PromptStrategy):
    def generate_prompt(self, input_text: str) -> str:
        return f"""
        Think creatively and provide an innovative perspective on:
        \{input_text\}
        
        Consider:
        - Alternative viewpoints
        - Creative solutions
        - Future implications
        - Unconventional approaches
        """

class AIContext:
    def __init__(self, strategy: PromptStrategy):
        self.strategy = strategy
    
    def set_strategy(self, strategy: PromptStrategy):
        self.strategy = strategy
    
    def process_input(self, input_text: str) -> str:
        prompt = self.strategy.generate_prompt(input_text)
        # Here you would send the prompt to an AI model
        return f"Generated prompt: \{prompt\}"

# Usage
simple_strategy = SimplePromptStrategy()
detailed_strategy = DetailedPromptStrategy()
creative_strategy = CreativePromptStrategy()

context = AIContext(simple_strategy)
print(context.process_input("What is AI?"))

context.set_strategy(detailed_strategy)
print(context.process_input("What is AI?"))

context.set_strategy(creative_strategy)
print(context.process_input("What is AI?"))
```

## AI-Specific Patterns

### Chain of Responsibility Pattern

Pass requests along a chain of handlers.

```python
from abc import ABC, abstractmethod
from typing import Optional

class Request:
    def __init__(self, text: str, request_type: str):
        self.text = text
        self.request_type = request_type
        self.response = None

class Handler(ABC):
    def __init__(self):
        self.next_handler: Optional[Handler] = None
    
    def set_next(self, handler: 'Handler') -> 'Handler':
        self.next_handler = handler
        return handler
    
    @abstractmethod
    def handle(self, request: Request) -> bool:
        pass

class InputValidationHandler(Handler):
    def handle(self, request: Request) -> bool:
        if not request.text or len(request.text.strip()) == 0:
            request.response = "Error: Empty input"
            return False
        
        if len(request.text) > 1000:
            request.response = "Error: Input too long"
            return False
        
        return self.next_handler.handle(request) if self.next_handler else True

class ContentFilterHandler(Handler):
    def handle(self, request: Request) -> bool:
        inappropriate_words = ['spam', 'inappropriate', 'blocked']
        
        for word in inappropriate_words:
            if word in request.text.lower():
                request.response = f"Error: Content contains inappropriate word: \{word\}"
                return False
        
        return self.next_handler.handle(request) if self.next_handler else True

class AIProcessingHandler(Handler):
    def handle(self, request: Request) -> bool:
        # Simulate AI processing
        request.response = f"AI processed: \{request.text\}"
        return True

# Usage
validation_handler = InputValidationHandler()
filter_handler = ContentFilterHandler()
ai_handler = AIProcessingHandler()

# Chain the handlers
validation_handler.set_next(filter_handler).set_next(ai_handler)

# Test requests
request1 = Request("Hello, AI!", "general")
validation_handler.handle(request1)
print(request1.response)

request2 = Request("", "general")
validation_handler.handle(request2)
print(request2.response)

request3 = Request("This is spam content", "general")
validation_handler.handle(request3)
print(request3.response)
```

### Template Method Pattern

Define the skeleton of an algorithm in a base class.

```python
from abc import ABC, abstractmethod

class AIPipeline(ABC):
    def process(self, input_data: str) -> str:
        """Template method defining the algorithm structure"""
        # Step 1: Preprocess
        processed_data = self.preprocess(input_data)
        
        # Step 2: Validate
        if not self.validate(processed_data):
            return "Validation failed"
        
        # Step 3: Generate response
        response = self.generate_response(processed_data)
        
        # Step 4: Post-process
        final_response = self.postprocess(response)
        
        return final_response
    
    @abstractmethod
    def preprocess(self, data: str) -> str:
        pass
    
    @abstractmethod
    def validate(self, data: str) -> bool:
        pass
    
    @abstractmethod
    def generate_response(self, data: str) -> str:
        pass
    
    @abstractmethod
    def postprocess(self, response: str) -> str:
        pass

class ChatbotPipeline(AIPipeline):
    def preprocess(self, data: str) -> str:
        return data.strip().lower()
    
    def validate(self, data: str) -> bool:
        return len(data) > 0 and len(data) <= 500
    
    def generate_response(self, data: str) -> str:
        return f"Chatbot response to: \{data\}"
    
    def postprocess(self, response: str) -> str:
        return response.capitalize()

class TranslationPipeline(AIPipeline):
    def preprocess(self, data: str) -> str:
        return data.strip()
    
    def validate(self, data: str) -> bool:
        return len(data) > 0
    
    def generate_response(self, data: str) -> str:
        return f"Translated: \{data\}"
    
    def postprocess(self, response: str) -> str:
        return response + " [Translation complete]"

# Usage
chatbot = ChatbotPipeline()
translation = TranslationPipeline()

print(chatbot.process("Hello, how are you?"))
print(translation.process("Bonjour, comment allez-vous?"))
```

## Best Practices

### 1. Choose the Right Pattern

- **Creational**: When object creation is complex or needs to be controlled
- **Structural**: When you need to compose objects or provide alternative interfaces
- **Behavioral**: When you need to manage algorithms, relationships, and responsibilities

### 2. Keep It Simple

- Don't over-engineer solutions
- Use patterns only when they add value
- Consider the complexity trade-offs

### 3. Document Your Patterns

- Explain why you chose a specific pattern
- Document the responsibilities of each component
- Provide usage examples

### 4. Test Your Patterns

- Unit test each pattern implementation
- Test pattern interactions
- Verify that patterns solve the intended problem

## Implementation Examples

### Configuration Management

```python
class ConfigManager:
    def __init__(self):
        self.config = \{\}
        self.observers = []
    
    def set_config(self, key: str, value: any):
        self.config[key] = value
        self.notify_observers(key, value)
    
    def get_config(self, key: str, default=None):
        return self.config.get(key, default)
    
    def add_observer(self, observer):
        self.observers.append(observer)
    
    def notify_observers(self, key: str, value: any):
        for observer in self.observers:
            observer.config_changed(key, value)

class LoggingObserver:
    def config_changed(self, key: str, value: any):
        print(f"Config changed: \{key\} = \{value\}")

# Usage
config = ConfigManager()
config.add_observer(LoggingObserver())
config.set_config('model_name', 'gpt-4')
```

### Error Handling Strategy

```python
class ErrorHandler:
    def __init__(self):
        self.strategies = {
            'retry': self.retry_strategy,
            'fallback': self.fallback_strategy,
            'ignore': self.ignore_strategy
        }
    
    def handle_error(self, error: Exception, strategy: str = 'retry'):
        if strategy in self.strategies:
            return self.strategies[strategy](error)
        else:
            raise error
    
    def retry_strategy(self, error: Exception):
        print(f"Retrying after error: \{error\}")
        # Implement retry logic
        return "Retry successful"
    
    def fallback_strategy(self, error: Exception):
        print(f"Using fallback for error: \{error\}")
        return "Fallback response"
    
    def ignore_strategy(self, error: Exception):
        print(f"Ignoring error: \{error\}")
        return None
```

> **Note:** The following article is reproduced verbatim from  
> Codecademy Team, *Codecademy* (2025):  
> [Figma Make Tutorial: Build Interactive Apps with AI](https://www.codecademy.com/article/figma-make-tutorial)  
> for internal educational use only (non-profit).

# Figma Make Tutorial: Build Interactive Apps with AI

Ever designed a great UI and thought, "I wish I could just make this work without jumping through extra tools or workflows"? What if you could bring your designs to life by describing what you want, no handoff, plugins, or context switching? That's precisely where Figma Make comes in!

Figma Make, launched at Config 2025, is Figma's AI-powered prompt-to-code environment that allows designers to build real, functional prototypes directly inside Figma. Unlike traditional files, it lets us use plain English to add logic, navigation, responsiveness, and interactivity to our designs without requiring manual coding.

Let's build a personalized finance app using Figma Make.

## Building a finance tracker app

In this project, we'll build a personalized finance tracker that helps users do exactly that, with a clean and interactive dashboard powered by Figma Make. This app gives users a snapshot of their financial health. It includes features like:

- A dashboard showing income, expenses, and account balances
- Monthly report generation, styled like a bank statement
- A transaction history with filters, tags, and categories

It's inspired by tools like Plaid, QuickBooks, and Notion-style finance templates, but it's streamlined for personal use.

Let's start by defining the visual structure, the wireframe. A strong wireframe sets the foundation for meaningful AI output.

Also, here's a video tutorial that walks through the same concepts step by step—with visuals, examples, and a real-time build. Use it alongside the text or on its own—whatever helps you learn best.

### Step 1: Create wireframes for your app

A wireframe is a low-fidelity blueprint of your app's layout. Create a wireframe for this app, focusing on the structure, which answers:

- "What goes where?"
- "How do screens connect?"
- "What components does the user need to interact with?"

Unlike typical prototypes, where wireframes are handed off to developers, in Figma Make, your wireframe becomes part of the functional build process. You can:

- Use it to plan the layout and logic clearly
- Feed it directly into the Figma Make file
- Guide your prompts more effectively, since the visual hierarchy already exists

Let's look at each screen in detail.

#### Screen 1: Dashboard overview

The dashboard is the main landing screen. It gives the user details of their current financial health, including their earnings and spending, and forming trends.

This screen will have:

- A top navigation bar with the app name and profile access
- Summary cards for total income and total expenses
- A toggleable line chart that switches views between income and expenses
- Quick action buttons like "Add Transaction", "View Report", "Export Data"

Here's a sample wireframe of the dashboard screen:

![Wireframe of a personal finance dashboard showing income, expenses, trends chart, and action buttons](https://static-assets.codecademy.com/figma-make/Wireframe-1-dashboard.png)
<sub>Source: *Codecademy*, Codecademy Team (2025).</sub>

> Note: The wireframes used here are just examples and you can use your layouts as the foundation for your prompts in Figma Make.

#### Screen 2: Monthly report page

The monthly report page will mimic a formatted statement view. Think of it like a printable snapshot of a user's income and expenses for any given month. It'll have the following components:

- A header with the report title and date filters
- A summary block showing totals and net savings
- A breakdown table by spending category
- A footer for optional disclaimers or notes

Here's a sample wireframe of this screen:

![Wireframe of a monthly financial summary with filters, income and expense overview, and a category breakdown table](https://static-assets.codecademy.com/figma-make/Wireframe-2-Monthly-financial-summary.png)
<sub>Source: *Codecademy*, Codecademy Team (2025).</sub>

#### Screen 3: Transactions details page

This is the most data-dense screen, designed to show the user a history of every transaction they've made. It'll have the following components:

- A search bar and filter options
- A list of transactions with details like date, amount, category, and description
- Pagination controls for large datasets
- Export functionality

Here's a sample wireframe of this screen:

![Wireframe of a transaction history page with search, filters, transaction list, and pagination](https://static-assets.codecademy.com/figma-make/Wireframe-3-Transaction-history.png)
<sub>Source: *Codecademy*, Codecademy Team (2025).</sub>

### Step 2: Set up your Figma Make file

Now that we have our wireframes, let's set up the Figma Make environment:

1. **Create a new Figma Make file**: Go to Figma and create a new file. You'll see a "Make" option in the file type selector.

2. **Import your wireframes**: You can either:
   - Create the wireframes directly in Figma Make
   - Import existing wireframes from other Figma files
   - Use the sample wireframes provided above as reference

3. **Set up the canvas**: Organize your screens in a logical flow, typically left to right or top to bottom.

### Step 3: Start with the dashboard screen

Let's begin building the dashboard. In Figma Make, you can use natural language to describe what you want:

**Prompt example**: "Create a dashboard with a header navigation bar, two summary cards for income and expenses, a line chart that can toggle between income and expense views, and three action buttons at the bottom."

The AI will generate the layout and basic styling. You can then refine it with more specific prompts:

**Refinement prompt**: "Make the income card green and the expense card red. Add icons to the action buttons and make them rounded with a subtle shadow."

### Step 4: Add interactivity and logic

This is where Figma Make really shines. You can add functionality without writing code:

**Navigation prompt**: "When the user clicks 'View Report', navigate to the monthly report screen."

**Data handling prompt**: "Create a data structure for transactions with fields for date, amount, category, and description. Display sample data in the dashboard."

**Chart functionality prompt**: "Make the line chart interactive. When users click the 'Income' or 'Expenses' toggle, update the chart data accordingly."

### Step 5: Build the monthly report screen

For the monthly report, you'll want to focus on data presentation and filtering:

**Layout prompt**: "Create a monthly report layout with a header showing the month and year, summary cards for total income, expenses, and net savings, and a detailed breakdown table."

**Filtering prompt**: "Add date picker controls that allow users to select different months. Update the report data when the date changes."

**Styling prompt**: "Style the report to look like a professional bank statement with clean typography and proper spacing."

### Step 6: Create the transaction history screen

The transaction history screen requires more complex data handling:

**Data structure prompt**: "Create a comprehensive transaction data structure with fields for ID, date, amount, category, description, and tags."

**Search functionality prompt**: "Add a search bar that filters transactions by description or category. Make it work in real-time as the user types."

**Pagination prompt**: "Implement pagination for the transaction list, showing 10 transactions per page with navigation controls."

### Step 7: Connect all screens together

Now it's time to make everything work together:

**Navigation system prompt**: "Create a navigation system that allows users to move between the dashboard, monthly report, and transaction history screens. Add a bottom navigation bar or breadcrumbs."

**Data consistency prompt**: "Ensure that data changes in one screen are reflected across all screens. For example, adding a transaction should update the dashboard totals and appear in the transaction history."

**State management prompt**: "Implement state management so that user preferences, filters, and current view are preserved when navigating between screens."

### Step 8: Add advanced features

Once the basic functionality is working, you can add more sophisticated features:

**Responsive design prompt**: "Make the app responsive so it works well on different screen sizes. Adjust layouts for mobile, tablet, and desktop views."

**Animations prompt**: "Add smooth transitions between screens and subtle animations for user interactions like button clicks and data updates."

**Export functionality prompt**: "Add the ability to export transaction data as CSV or PDF reports."

### Step 9: Test and refine

Testing is crucial for any app, even AI-generated ones:

**User testing prompt**: "Create a test scenario where a user adds a new transaction, views the monthly report, and exports their data. Ensure all flows work correctly."

**Error handling prompt**: "Add error handling for edge cases like empty data, network issues, or invalid user input."

**Performance optimization prompt**: "Optimize the app for performance, especially when handling large datasets or complex calculations."

## Best Practices for Figma Make

### 1. Start with Clear Requirements

Before diving into prompts, clearly define what you want to build:

- **User stories**: Write down what users should be able to do
- **Functional requirements**: List specific features and behaviors
- **Technical constraints**: Consider performance, compatibility, and scalability

### 2. Use Iterative Development

Build your app in small, manageable steps:

- **Start simple**: Begin with basic layouts and functionality
- **Add complexity gradually**: Build upon working features
- **Test frequently**: Verify each addition works before moving on

### 3. Write Effective Prompts

The quality of your prompts directly affects the output:

- **Be specific**: Include details about layout, styling, and behavior
- **Use clear language**: Avoid ambiguous terms and jargon
- **Provide context**: Reference existing elements and relationships
- **Iterate**: Refine prompts based on the results you get

### 4. Leverage Figma's Design System

Take advantage of Figma's built-in design capabilities:

- **Use components**: Create reusable UI elements
- **Apply styles**: Use consistent colors, typography, and spacing
- **Maintain consistency**: Ensure visual coherence across screens

### 5. Test Across Different Scenarios

Don't just test the happy path:

- **Edge cases**: Test with empty data, invalid inputs, and error conditions
- **User flows**: Walk through complete user journeys
- **Performance**: Test with realistic data volumes
- **Accessibility**: Ensure the app works for users with different needs

## Common Challenges and Solutions

### Challenge 1: Complex Data Relationships

**Problem**: Managing relationships between different data entities (transactions, categories, accounts).

**Solution**: Use clear data structures and implement proper state management. Break complex relationships into smaller, manageable pieces.

### Challenge 2: Performance with Large Datasets

**Problem**: The app becomes slow when handling many transactions.

**Solution**: Implement pagination, lazy loading, and efficient data filtering. Consider data virtualization for very large datasets.

### Challenge 3: Responsive Design

**Problem**: The app doesn't work well on different screen sizes.

**Solution**: Design with mobile-first approach and use flexible layouts. Test on various devices and screen sizes.

### Challenge 4: State Management

**Problem**: Data gets out of sync between different screens.

**Solution**: Implement a centralized state management system and ensure all components update consistently.

## Advanced Techniques

### 1. Custom Components

Create reusable components for common UI patterns:

**Prompt**: "Create a reusable transaction card component that displays date, amount, category, and description. Make it customizable for different transaction types."

### 2. Data Visualization

Add charts and graphs to make data more meaningful:

**Prompt**: "Create a pie chart showing spending by category and a line chart showing spending trends over time."

### 3. User Preferences

Allow users to customize their experience:

**Prompt**: "Add a settings screen where users can choose their preferred currency, date format, and default view."

### 4. Offline Functionality

Make the app work without an internet connection:

**Prompt**: "Implement local storage so users can add transactions offline and sync when they're back online."

## Conclusion

Figma Make represents a significant shift in how designers and developers can collaborate. By combining the visual design capabilities of Figma with AI-powered code generation, it opens up new possibilities for rapid prototyping and development.

The key to success with Figma Make is understanding that it's not just about generating code—it's about creating a seamless workflow between design and development. The better you can describe what you want, the better the results will be.

Remember that Figma Make is still evolving, and the quality of your prompts will improve with practice. Start with simple projects, experiment with different approaches, and gradually build up to more complex applications.

As you become more comfortable with Figma Make, you'll find that it can significantly speed up your development process while maintaining the quality and consistency of your designs. The ability to iterate quickly and see immediate results makes it an invaluable tool for modern app development.

Whether you're a designer looking to bring your ideas to life or a developer wanting to prototype quickly, Figma Make provides a powerful platform for building interactive applications with AI assistance.

> **Note:** The following article is reproduced verbatim from  
> Smashing Magazine Team, *Smashing Magazine* (2025):  
> [Beyond The Hype: What AI Can Really Do For Product Design](https://www.smashingmagazine.com/2025/08/beyond-hype-what-ai-can-do-product-design/)  
> for internal educational use only (non-profit).

# Beyond The Hype: What AI Can Really Do For Product Design

These days, it's easy to find curated lists of AI tools for designers, galleries of generated illustrations, and countless prompt libraries. What's much harder to find is a clear view of how AI is actually integrated into the everyday workflow of a product designer — not for experimentation, but for real, meaningful outcomes.

I've gone through that journey myself: testing AI across every major stage of the design process, from ideation and prototyping to visual design and user research. Along the way, I've built a simple, repeatable workflow that significantly boosts my productivity.

In this article, I'll share what's already working and break down some of the most common objections I've encountered — many of which I've faced personally.

## Stage 1: Idea Generation Without The Clichés

Pushback: "Whenever I ask AI to suggest ideas, I just get a list of clichés. It can't produce the kind of creative thinking expected from a product designer."

That's a fair point. AI doesn't know the specifics of your product, the full context of your task, or many other critical nuances. The most obvious fix is to "feed it" all the documentation you have. But that's a common mistake as it often leads to even worse results: the context gets flooded with irrelevant information, and the AI's answers become vague and unfocused.

Current-gen models can technically process thousands of words, but the longer the input, the higher the risk of missing something important, especially content buried in the middle. This is known as the "lost in the middle" problem.

To get meaningful results, AI doesn't just need more information — it needs the right information, delivered in the right way. That's where the RAG approach comes in.

### How RAG Works

Think of RAG as a smart assistant working with your personal library of documents. You upload your files, and the assistant reads each one, creating a short summary — a set of bookmarks (semantic tags) that capture the key topics, terms, scenarios, and concepts. These summaries are stored in a kind of "card catalog," called a vector database.

When you ask a question, the assistant doesn't reread every document from cover to cover. Instead, it compares your query to the bookmarks, retrieves only the most relevant excerpts (chunks), and sends those to the language model to generate a final answer.

### How Is This Different from Just Dumping a Doc into the Chat?

Let's break it down:

**Typical chat interaction**

It's like asking your assistant to read a 100-page book from start to finish every time you have a question. Technically, all the information is "in front of them," but it's easy to miss something, especially if it's in the middle. This is exactly what the "lost in the middle" issue refers to.

**RAG approach**

You ask your smart assistant a question, and it retrieves only the relevant pages (chunks) from different documents. It's faster and more accurate, but it introduces a few new risks:

- **Ambiguous question**: You ask, "How can we make the project safer?" and the assistant brings you documents about cybersecurity, not finance.
- **Mixed chunks**: A single chunk might contain a mix of marketing, design, and engineering notes. That blurs the meaning so the assistant can't tell what the core topic is.
- **Semantic gap**: You ask, "How can we speed up the app?" but the document says, "Optimize API response time." For a human, that's obviously related. For a machine, not always.

![Diagram showing how RAG works: a user prompt triggers semantic search through a knowledge base. Relevant chunks are sent to a language model, which generates an answer based on retrieved content.](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/beyond-hype-what-ai-can-do-product-design/1-rag-approach.png)
<sub>Instead of using the model's memory, it searches your documents and builds a response based on what it finds. (Large preview)</sub>

These aren't reasons to avoid RAG or AI altogether. Most of them can be avoided with better preparation of your knowledge base and more precise prompts. So, where do you start?

> **Note:** The following article is reproduced verbatim from  
> Smashing Magazine Team, *Smashing Magazine* (2025):  
> [Designing With AI, Not Around It: Practical Advanced Techniques For Product Design Use Cases](https://www.smashingmagazine.com/2025/08/designing-with-ai-practical-techniques-product-design/)  
> for internal educational use only (non-profit).

# Designing With AI, Not Around It: Practical Advanced Techniques For Product Design Use Cases

AI is almost everywhere — it writes text, makes music, generates code, draws pictures, runs research, chats with you — and apparently even understands people better than they understand themselves?!

It's a lot to take in. The pace is wild, and new tools pop up faster than anyone has time to try them. Amid the chaos, one thing is clear: this isn't hype, but it's structural change.

According to the Future of Jobs Report 2025 by the World Economic Forum, one of the fastest-growing, most in-demand skills for the next five years is the ability to work with AI and Big Data. That applies to almost every role — including product design.

![A figure showing skills on the rise in 2025-2030, which places AI and big data on the first place](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/designing-with-ai-practical-techniques-product-design/1-skills-on-the-rise-2025.png)
<sub>Source: *Smashing Magazine*, Smashing Magazine Team (2025).</sub>

What do companies want most from their teams? Right, efficiency. And AI can make people way more efficient. We'd easily spend 3x more time on tasks like replying to our managers without AI helping out. We're learning to work with it, but many of us are still figuring out how to meet the rising bar.

That's especially important for designers, whose work is all about empathy, creativity, critical thinking, and working across disciplines. It's a uniquely human mix. At least, that's what we tell ourselves.

Even as debates rage about AI's limitations, tools today (June 2025 — timestamp matters in this fast-moving space) already assist with research, ideation, and testing, sometimes better than expected.

Of course, not everyone agrees. AI hallucinates, loses context, and makes things up. So how can both views exist at the same time? Very simple. It's because both are true: AI is deeply flawed and surprisingly useful. The trick is knowing how to work with its strengths while managing its weaknesses. The real question isn't whether AI is good or bad — it's how we, as designers, stay sharp, stay valuable, and stay in the loop.

## Why Prompting Matters

Prompting matters more than most people realize because even small tweaks in how you ask can lead to radically different outputs. To see how this works in practice, let's look at a simple example.

Imagine you want to improve the onboarding experience in your product. On the left, you have the prompt you send to AI. On the right, the response you get back.

This side-by-side shows just how much even the smallest prompt details can change what AI gives you.

Talking to an AI model isn't that different from talking to a person. If you explain your thoughts clearly, you get a better understanding and communication overall.

> Advanced prompting is about moving beyond one-shot, throwaway prompts. It's an iterative, structured process of refining your inputs using different techniques so you can guide the AI toward more useful results. It focuses on being intentional with every word you put in, giving the AI not just the task but also the path to approach it step by step, so it can actually do the job.

![Advanced prompting vs basic promting](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/designing-with-ai-practical-techniques-product-design/2-advanced-prompting.png)
<sub>Source: *Smashing Magazine*, Smashing Magazine Team (2025).</sub>

Where basic prompting throws your question at the model and hopes for a quick answer, advanced prompting helps you explore options, evaluate branches of reasoning, and converge on clear, actionable outputs.

But that doesn't mean simple prompts are useless. On the contrary, short, focused prompts work well when the task is narrow, factual, or time-sensitive. They're great for idea generation, quick clarifications, or anything where deep reasoning isn't required. Think of prompting as a scale, not a binary. The simpler the task, the faster a lightweight prompt can get the job done. The more complex the task, the more structure it needs.

In this article, we'll dive into how advanced prompting can empower different product & design use cases, speeding up your workflow and improving your results — whether you're researching, brainstorming, testing, or beyond. Let's dive in.

## Practical Cases

In the next section, we'll explore six practical prompting techniques that we've found most useful in real product design work. These aren't abstract theories — each one is grounded in hands-on experience, tested across research, ideation, and evaluation tasks. Think of them as modular tools: you can mix, match, and adapt them depending on your use case. For each, we'll explain the thinking behind it and walk through a sample prompt.

Important note: The prompts you'll see are not copy-paste recipes. Some are structured templates you can reuse with small tweaks; others are more specific, meant to spark your thinking. Use them as scaffolds, not scripts.

### 1. Task Decomposition By JTBD

## Next Steps

- **Study**: Learn more about design patterns and their applications
- **Practice**: Implement patterns in your own projects
- **Refactor**: Apply patterns to existing code to improve structure
- **Share**: Document and share pattern implementations with your team

## Sources

- [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)
- [Python Design Patterns](https://python-patterns.guide/)
- [Refactoring Guru - Design Patterns](https://refactoring.guru/design-patterns)

## Collaboration Prompts for Engineers

### For Frontend Developers
"Implement the Observer pattern for real-time UI updates"

### For Backend Developers
"Design a Strategy pattern for different authentication methods"

### For DevOps Engineers
"Create a Factory pattern for different deployment strategies"

### For Data Scientists
"Build a Chain of Responsibility pattern for data validation pipelines"
